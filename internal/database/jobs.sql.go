// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getJobsForNode = `-- name: GetJobsForNode :many
SELECT j.id, j.project, j.spider, j.job, j.status, j.deleted, j.create_time, j.update_time, j.pages, j.items, j.pid,
       j.start, j.runtime, j.finish, j.href_log, j.href_items, j.node, j.error, u1.username AS started_by_username,
       u2.username AS stopped_by_username
FROM jobs j
         LEFT JOIN users u1 ON j.started_by = u1.ID
         LEFT JOIN users u2 ON j.stopped_by = u2.ID
WHERE j.node = ? AND j.deleted = 0
ORDER BY CASE
             WHEN j.finish IS NULL THEN j.runtime
             ELSE j.finish
             END DESC
LIMIT ? OFFSET ?
`

type GetJobsForNodeParams struct {
	Node   string
	Limit  int64
	Offset int64
}

type GetJobsForNodeRow struct {
	ID                int64
	Project           string
	Spider            string
	Job               string
	Status            string
	Deleted           bool
	CreateTime        time.Time
	UpdateTime        time.Time
	Pages             sql.NullInt64
	Items             sql.NullInt64
	Pid               sql.NullInt64
	Start             sql.NullTime
	Runtime           sql.NullString
	Finish            sql.NullTime
	HrefLog           sql.NullString
	HrefItems         sql.NullString
	Node              string
	Error             sql.NullString
	StartedByUsername sql.NullString
	StoppedByUsername sql.NullString
}

func (q *Queries) GetJobsForNode(ctx context.Context, arg GetJobsForNodeParams) ([]GetJobsForNodeRow, error) {
	rows, err := q.query(ctx, q.getJobsForNodeStmt, getJobsForNode, arg.Node, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobsForNodeRow
	for rows.Next() {
		var i GetJobsForNodeRow
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Spider,
			&i.Job,
			&i.Status,
			&i.Deleted,
			&i.CreateTime,
			&i.UpdateTime,
			&i.Pages,
			&i.Items,
			&i.Pid,
			&i.Start,
			&i.Runtime,
			&i.Finish,
			&i.HrefLog,
			&i.HrefItems,
			&i.Node,
			&i.Error,
			&i.StartedByUsername,
			&i.StoppedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalJobCountForNode = `-- name: GetTotalJobCountForNode :one
SELECT COUNT(*) FROM jobs WHERE node = ? AND deleted = 0
`

func (q *Queries) GetTotalJobCountForNode(ctx context.Context, node string) (int64, error) {
	row := q.queryRow(ctx, q.getTotalJobCountForNodeStmt, getTotalJobCountForNode, node)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO jobs (
    project, spider, job, status, deleted, create_time, update_time,
    pages, items, pid, start, runtime, finish, href_log, href_items, node, task_id, started_by, stopped_by
)
VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    ?13,
    ?14,
    ?15,
    ?16,
    ?17,
    ?18,
        ?19
       )
    ON CONFLICT(project, spider, job)
DO UPDATE SET
    status = EXCLUDED.status,
    update_time = EXCLUDED.update_time,
    pages = COALESCE(EXCLUDED.pages, jobs.pages),
    items = COALESCE(EXCLUDED.items, jobs.items),
    pid = COALESCE(EXCLUDED.pid, jobs.pid),
    start = COALESCE(EXCLUDED.start, jobs.start),
    runtime = COALESCE(EXCLUDED.runtime, jobs.runtime),
    finish = COALESCE(EXCLUDED.finish, jobs.finish),
    href_log = COALESCE(EXCLUDED.href_log, jobs.href_log),
    href_items = COALESCE(EXCLUDED.href_items, jobs.href_items),
    started_by = COALESCE(EXCLUDED.started_by, jobs.started_by),
    stopped_by = COALESCE(EXCLUDED.stopped_by, jobs.stopped_by)
WHERE jobs.deleted = 0
AND EXCLUDED.update_time >= jobs.update_time
RETURNING id, project, spider, job, status, deleted, create_time, update_time, pages, items, pid, start, runtime, finish, href_log, href_items, node, task_id, error, started_by, stopped_by
`

type InsertJobParams struct {
	Project    string
	Spider     string
	Job        string
	Status     string
	Deleted    bool
	CreateTime time.Time
	UpdateTime time.Time
	Pages      sql.NullInt64
	Items      sql.NullInt64
	Pid        sql.NullInt64
	Start      sql.NullTime
	Runtime    sql.NullString
	Finish     sql.NullTime
	HrefLog    sql.NullString
	HrefItems  sql.NullString
	Node       string
	TaskID     interface{}
	StartedBy  interface{}
	StoppedBy  interface{}
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Job, error) {
	row := q.queryRow(ctx, q.insertJobStmt, insertJob,
		arg.Project,
		arg.Spider,
		arg.Job,
		arg.Status,
		arg.Deleted,
		arg.CreateTime,
		arg.UpdateTime,
		arg.Pages,
		arg.Items,
		arg.Pid,
		arg.Start,
		arg.Runtime,
		arg.Finish,
		arg.HrefLog,
		arg.HrefItems,
		arg.Node,
		arg.TaskID,
		arg.StartedBy,
		arg.StoppedBy,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Project,
		&i.Spider,
		&i.Job,
		&i.Status,
		&i.Deleted,
		&i.CreateTime,
		&i.UpdateTime,
		&i.Pages,
		&i.Items,
		&i.Pid,
		&i.Start,
		&i.Runtime,
		&i.Finish,
		&i.HrefLog,
		&i.HrefItems,
		&i.Node,
		&i.TaskID,
		&i.Error,
		&i.StartedBy,
		&i.StoppedBy,
	)
	return i, err
}

const searchNodeJobs = `-- name: SearchNodeJobs :many
SELECT j.id, j.project, j.spider, j.job, j.status, j.deleted, j.create_time, j.update_time, j.pages, j.items, j.pid,
       j.start, j.runtime, j.finish, j.href_log, j.href_items, j.node, j.error, u1.username AS started_by_username,
       u2.username AS stopped_by_username
FROM jobs j
         LEFT JOIN users u1 ON j.started_by = u1.ID
         LEFT JOIN users u2 ON j.stopped_by = u2.ID
WHERE
    (LOWER(j.spider) LIKE '%' || LOWER(?1) || '%' OR
     LOWER(j.job) LIKE '%' || LOWER(?1) || '%')
  AND j.node = ?2
  AND j.deleted = 0
ORDER BY CASE
             WHEN j.finish IS NULL THEN j.runtime
             ELSE j.finish
             END DESC
`

type SearchNodeJobsParams struct {
	SearchTerm string
	Node       string
}

type SearchNodeJobsRow struct {
	ID                int64
	Project           string
	Spider            string
	Job               string
	Status            string
	Deleted           bool
	CreateTime        time.Time
	UpdateTime        time.Time
	Pages             sql.NullInt64
	Items             sql.NullInt64
	Pid               sql.NullInt64
	Start             sql.NullTime
	Runtime           sql.NullString
	Finish            sql.NullTime
	HrefLog           sql.NullString
	HrefItems         sql.NullString
	Node              string
	Error             sql.NullString
	StartedByUsername sql.NullString
	StoppedByUsername sql.NullString
}

func (q *Queries) SearchNodeJobs(ctx context.Context, arg SearchNodeJobsParams) ([]SearchNodeJobsRow, error) {
	rows, err := q.query(ctx, q.searchNodeJobsStmt, searchNodeJobs, arg.SearchTerm, arg.Node)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNodeJobsRow
	for rows.Next() {
		var i SearchNodeJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Spider,
			&i.Job,
			&i.Status,
			&i.Deleted,
			&i.CreateTime,
			&i.UpdateTime,
			&i.Pages,
			&i.Items,
			&i.Pid,
			&i.Start,
			&i.Runtime,
			&i.Finish,
			&i.HrefLog,
			&i.HrefItems,
			&i.Node,
			&i.Error,
			&i.StartedByUsername,
			&i.StoppedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setErrorWhereJobId = `-- name: SetErrorWhereJobId :exec
UPDATE jobs
SET error = ?, status = 'error'
WHERE jobs.job = ?2 AND jobs.project=?3 AND jobs.node=?4
`

type SetErrorWhereJobIdParams struct {
	Error   sql.NullString
	JobID   string
	Project string
	Node    string
}

func (q *Queries) SetErrorWhereJobId(ctx context.Context, arg SetErrorWhereJobIdParams) error {
	_, err := q.exec(ctx, q.setErrorWhereJobIdStmt, setErrorWhereJobId,
		arg.Error,
		arg.JobID,
		arg.Project,
		arg.Node,
	)
	return err
}

const setStoppedByOnJob = `-- name: SetStoppedByOnJob :exec
UPDATE jobs SET stopped_by=? WHERE job=? AND project=? AND node=?
`

type SetStoppedByOnJobParams struct {
	StoppedBy interface{}
	Job       string
	Project   string
	Node      string
}

func (q *Queries) SetStoppedByOnJob(ctx context.Context, arg SetStoppedByOnJobParams) error {
	_, err := q.exec(ctx, q.setStoppedByOnJobStmt, setStoppedByOnJob,
		arg.StoppedBy,
		arg.Job,
		arg.Project,
		arg.Node,
	)
	return err
}

const softDeleteJob = `-- name: SoftDeleteJob :exec
UPDATE jobs SET deleted = ? WHERE job = ?
`

type SoftDeleteJobParams struct {
	Deleted bool
	Job     string
}

func (q *Queries) SoftDeleteJob(ctx context.Context, arg SoftDeleteJobParams) error {
	_, err := q.exec(ctx, q.softDeleteJobStmt, softDeleteJob, arg.Deleted, arg.Job)
	return err
}

const startFinishRuntimeLogsItemsForJobWithJobID = `-- name: StartFinishRuntimeLogsItemsForJobWithJobID :one
SELECT jobs.Start, jobs.Runtime, jobs.Finish, jobs.href_log, jobs.href_items, jobs.spider, jobs.Project, jobs.job, jobs.node FROM jobs WHERE job = ? LIMIT 1
`

type StartFinishRuntimeLogsItemsForJobWithJobIDRow struct {
	Start     sql.NullTime
	Runtime   sql.NullString
	Finish    sql.NullTime
	HrefLog   sql.NullString
	HrefItems sql.NullString
	Spider    string
	Project   string
	Job       string
	Node      string
}

func (q *Queries) StartFinishRuntimeLogsItemsForJobWithJobID(ctx context.Context, job string) (StartFinishRuntimeLogsItemsForJobWithJobIDRow, error) {
	row := q.queryRow(ctx, q.startFinishRuntimeLogsItemsForJobWithJobIDStmt, startFinishRuntimeLogsItemsForJobWithJobID, job)
	var i StartFinishRuntimeLogsItemsForJobWithJobIDRow
	err := row.Scan(
		&i.Start,
		&i.Runtime,
		&i.Finish,
		&i.HrefLog,
		&i.HrefItems,
		&i.Spider,
		&i.Project,
		&i.Job,
		&i.Node,
	)
	return i, err
}
