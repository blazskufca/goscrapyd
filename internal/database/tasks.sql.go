// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tasks.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteTaskWhereUUID = `-- name: DeleteTaskWhereUUID :exec
DELETE FROM tasks WHERE id = ?
`

func (q *Queries) DeleteTaskWhereUUID(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTaskWhereUUIDStmt, deleteTaskWhereUUID, id)
	return err
}

const getTaskWithUUID = `-- name: GetTaskWithUUID :one
SELECT id, name, create_time, update_time, project, spider, jobid, settings_arguments, selected_nodes, cron_string, paused, created_by, modified_by FROM tasks WHERE id = ?
`

func (q *Queries) GetTaskWithUUID(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.queryRow(ctx, q.getTaskWithUUIDStmt, getTaskWithUUID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateTime,
		&i.UpdateTime,
		&i.Project,
		&i.Spider,
		&i.Jobid,
		&i.SettingsArguments,
		&i.SelectedNodes,
		&i.CronString,
		&i.Paused,
		&i.CreatedBy,
		&i.ModifiedBy,
	)
	return i, err
}

const getTasks = `-- name: GetTasks :many
SELECT id, name, create_time, update_time, project, spider, jobid, settings_arguments, selected_nodes, cron_string, paused, created_by, modified_by FROM tasks
`

func (q *Queries) GetTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.query(ctx, q.getTasksStmt, getTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreateTime,
			&i.UpdateTime,
			&i.Project,
			&i.Spider,
			&i.Jobid,
			&i.SettingsArguments,
			&i.SelectedNodes,
			&i.CronString,
			&i.Paused,
			&i.CreatedBy,
			&i.ModifiedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksWithLatestJobMetadata = `-- name: GetTasksWithLatestJobMetadata :many
SELECT t.id AS task_id,
       t.name,
       t.create_time AS task_create_time,
       t.update_time AS task_update_time,
       t.project,
       t.spider,
       t.jobid,
       t.settings_arguments,
       t.selected_nodes,
       t.cron_string,
       t.paused,
       creator.username AS created_by_username,
       modifier.username AS modified_by_username,
       j.id AS job_id,
       j.create_time AS job_create_time,
       j.pages AS job_pages,
       j.items AS job_items,
       j.start AS job_start,
       j.runtime AS job_runtime,
       j.finish AS job_finish,
       j.href_log,
       j.href_items,
       j.node AS job_node
FROM tasks t
         LEFT JOIN users creator ON t.created_by = creator.ID
         LEFT JOIN users modifier ON t.modified_by = modifier.ID
         LEFT JOIN jobs j ON j.task_id = t.id
    AND j.status = 'finished'
    AND j.update_time = (
        SELECT MAX(update_time)
        FROM jobs
        WHERE task_id = t.id AND status = 'finished' AND j.node = t.selected_nodes LIMIT 1
    )
ORDER BY t.name DESC
`

type GetTasksWithLatestJobMetadataRow struct {
	TaskID             uuid.UUID
	Name               sql.NullString
	TaskCreateTime     time.Time
	TaskUpdateTime     time.Time
	Project            string
	Spider             string
	Jobid              string
	SettingsArguments  string
	SelectedNodes      string
	CronString         string
	Paused             bool
	CreatedByUsername  sql.NullString
	ModifiedByUsername sql.NullString
	JobID              sql.NullInt64
	JobCreateTime      sql.NullTime
	JobPages           sql.NullInt64
	JobItems           sql.NullInt64
	JobStart           sql.NullTime
	JobRuntime         sql.NullString
	JobFinish          sql.NullTime
	HrefLog            sql.NullString
	HrefItems          sql.NullString
	JobNode            sql.NullString
}

func (q *Queries) GetTasksWithLatestJobMetadata(ctx context.Context) ([]GetTasksWithLatestJobMetadataRow, error) {
	rows, err := q.query(ctx, q.getTasksWithLatestJobMetadataStmt, getTasksWithLatestJobMetadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksWithLatestJobMetadataRow
	for rows.Next() {
		var i GetTasksWithLatestJobMetadataRow
		if err := rows.Scan(
			&i.TaskID,
			&i.Name,
			&i.TaskCreateTime,
			&i.TaskUpdateTime,
			&i.Project,
			&i.Spider,
			&i.Jobid,
			&i.SettingsArguments,
			&i.SelectedNodes,
			&i.CronString,
			&i.Paused,
			&i.CreatedByUsername,
			&i.ModifiedByUsername,
			&i.JobID,
			&i.JobCreateTime,
			&i.JobPages,
			&i.JobItems,
			&i.JobStart,
			&i.JobRuntime,
			&i.JobFinish,
			&i.HrefLog,
			&i.HrefItems,
			&i.JobNode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTask = `-- name: InsertTask :one
INSERT INTO tasks (
   id, name, project, spider, jobid, settings_arguments, selected_nodes, cron_string, paused, created_by
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, name, create_time, update_time, project, spider, jobid, settings_arguments, selected_nodes, cron_string, paused, created_by, modified_by
`

type InsertTaskParams struct {
	ID                uuid.UUID
	Name              sql.NullString
	Project           string
	Spider            string
	Jobid             string
	SettingsArguments string
	SelectedNodes     string
	CronString        string
	Paused            bool
	CreatedBy         interface{}
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) (Task, error) {
	row := q.queryRow(ctx, q.insertTaskStmt, insertTask,
		arg.ID,
		arg.Name,
		arg.Project,
		arg.Spider,
		arg.Jobid,
		arg.SettingsArguments,
		arg.SelectedNodes,
		arg.CronString,
		arg.Paused,
		arg.CreatedBy,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateTime,
		&i.UpdateTime,
		&i.Project,
		&i.Spider,
		&i.Jobid,
		&i.SettingsArguments,
		&i.SelectedNodes,
		&i.CronString,
		&i.Paused,
		&i.CreatedBy,
		&i.ModifiedBy,
	)
	return i, err
}

const searchTasksTable = `-- name: SearchTasksTable :many
SELECT t.id AS task_id,
       t.name,
       t.create_time AS task_create_time,
       t.update_time AS task_update_time,
       t.project,
       t.spider,
       t.jobid,
       t.settings_arguments,
       t.selected_nodes,
       t.cron_string,
       t.paused,
       creator.username AS created_by_username,
       modifier.username AS modified_by_username,
       j.id AS job_id,
       j.create_time AS job_create_time,
       j.pages AS job_pages,
       j.items AS job_items,
       j.start AS job_start,
       j.runtime AS job_runtime,
       j.finish AS job_finish,
       j.href_log,
       j.href_items,
       j.node AS job_node
FROM tasks t
         LEFT JOIN users creator ON t.created_by = creator.ID
         LEFT JOIN users modifier ON t.modified_by = modifier.ID
         LEFT JOIN jobs j ON j.task_id = t.id
    AND j.status = 'finished'
    AND j.update_time = (
        SELECT MAX(update_time)
        FROM jobs
        WHERE task_id = t.id AND status = 'finished' AND j.node = t.selected_nodes LIMIT 1
    )
WHERE
    LOWER(t.name) LIKE '%' || LOWER(?1) || '%' OR
    LOWER(t.spider) LIKE '%' || LOWER(?1) || '%'
ORDER BY t.name
`

type SearchTasksTableRow struct {
	TaskID             uuid.UUID
	Name               sql.NullString
	TaskCreateTime     time.Time
	TaskUpdateTime     time.Time
	Project            string
	Spider             string
	Jobid              string
	SettingsArguments  string
	SelectedNodes      string
	CronString         string
	Paused             bool
	CreatedByUsername  sql.NullString
	ModifiedByUsername sql.NullString
	JobID              sql.NullInt64
	JobCreateTime      sql.NullTime
	JobPages           sql.NullInt64
	JobItems           sql.NullInt64
	JobStart           sql.NullTime
	JobRuntime         sql.NullString
	JobFinish          sql.NullTime
	HrefLog            sql.NullString
	HrefItems          sql.NullString
	JobNode            sql.NullString
}

func (q *Queries) SearchTasksTable(ctx context.Context, searchterm string) ([]SearchTasksTableRow, error) {
	rows, err := q.query(ctx, q.searchTasksTableStmt, searchTasksTable, searchterm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTasksTableRow
	for rows.Next() {
		var i SearchTasksTableRow
		if err := rows.Scan(
			&i.TaskID,
			&i.Name,
			&i.TaskCreateTime,
			&i.TaskUpdateTime,
			&i.Project,
			&i.Spider,
			&i.Jobid,
			&i.SettingsArguments,
			&i.SelectedNodes,
			&i.CronString,
			&i.Paused,
			&i.CreatedByUsername,
			&i.ModifiedByUsername,
			&i.JobID,
			&i.JobCreateTime,
			&i.JobPages,
			&i.JobItems,
			&i.JobStart,
			&i.JobRuntime,
			&i.JobFinish,
			&i.HrefLog,
			&i.HrefItems,
			&i.JobNode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET
    name = ?,
    project = ?,
    spider = ?,
    jobid = ?,
    settings_arguments = ?,
    selected_nodes = ?,
    cron_string = ?,
    paused = ?,
    modified_by = ?
WHERE id = ?
`

type UpdateTaskParams struct {
	Name              sql.NullString
	Project           string
	Spider            string
	Jobid             string
	SettingsArguments string
	SelectedNodes     string
	CronString        string
	Paused            bool
	ModifiedBy        interface{}
	ID                uuid.UUID
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.exec(ctx, q.updateTaskStmt, updateTask,
		arg.Name,
		arg.Project,
		arg.Spider,
		arg.Jobid,
		arg.SettingsArguments,
		arg.SelectedNodes,
		arg.CronString,
		arg.Paused,
		arg.ModifiedBy,
		arg.ID,
	)
	return err
}

const updateTaskPaused = `-- name: UpdateTaskPaused :exec
UPDATE tasks SET paused=? WHERE id = ?
`

type UpdateTaskPausedParams struct {
	Paused bool
	ID     uuid.UUID
}

func (q *Queries) UpdateTaskPaused(ctx context.Context, arg UpdateTaskPausedParams) error {
	_, err := q.exec(ctx, q.updateTaskPausedStmt, updateTaskPaused, arg.Paused, arg.ID)
	return err
}
